import { app, BrowserWindow, screen, Menu, ipcMain } from 'electron';
import * as https from 'https';
import * as http from 'http';
import { AutoUpdater } from './auto-updater';
import { registerBlinkImageFetcher } from './main/ipc-fetch-blink';
import { setBlinkAuth } from './main/blink-auth';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Hue Bridge API handlers - must be registered before app is ready
console.log('💡 Registering Hue IPC handlers...');

ipcMain.handle('hue-discover', async () => {
  console.log('💡 hue-discover handler called');
  return new Promise((resolve, reject) => {
    https.get('https://discovery.meethue.com/', (res) => {
      let data = '';
      res.on('data', (chunk) => { data += chunk; });
      res.on('end', () => {
        try {
          const bridges = JSON.parse(data);
          const result = bridges.length > 0 ? bridges[0].internalipaddress : null;
          console.log('💡 Discovery result:', result);
          resolve(result);
        } catch (error) {
          console.error('💡 Discovery error:', error);
          reject(error);
        }
      });
    }).on('error', (error) => {
      console.error('💡 HTTPS error:', error);
      reject(error);
    });
  });
});

ipcMain.handle('hue-request', async (event, { bridgeIP, path, method, body }) => {
  console.log(`💡 hue-request handler called: ${method} http://${bridgeIP}${path}`);
  return new Promise((resolve, reject) => {
    const options = {
      hostname: bridgeIP,
      port: 80,
      path: path,
      method: method || 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    const req = http.request(options, (res) => {
      let data = '';
      res.on('data', (chunk) => { data += chunk; });
      res.on('end', () => {
        try {
          const result = JSON.parse(data);
          console.log('💡 Request result:', result);
          resolve(result);
        } catch (error) {
          console.log('💡 Request result (raw):', data);
          resolve(data);
        }
      });
    });

    req.on('error', (error) => {
      console.error('💡 HTTP error:', error);
      reject(error);
    });

    if (body) {
      req.write(JSON.stringify(body));
    }

    req.end();
  });
});

console.log('💡 Hue IPC handlers registered successfully');

// Blink Camera API handlers
console.log('📹 Registering Blink IPC handlers...');

ipcMain.handle('blink-request', async (event, { url, method, headers, body }) => {
  console.log(`📹 blink-request handler called: ${method} ${url}`);
  return new Promise((resolve, reject) => {
    const urlObj = new URL(url);
    const isHttps = urlObj.protocol === 'https:';
    const httpModule = isHttps ? https : http;

    const options = {
      hostname: urlObj.hostname,
      port: isHttps ? 443 : 80,
      path: urlObj.pathname + urlObj.search,
      method: method || 'GET',
      headers: headers || {
        'Content-Type': 'application/json',
      },
    };

    const req = httpModule.request(options, (res) => {
      let data = '';
      res.on('data', (chunk) => { data += chunk; });
      res.on('end', () => {
        try {
          const result = JSON.parse(data);
          console.log('📹 Request result:', result);
          resolve(result);
        } catch (error) {
          console.log('📹 Request result (raw):', data);
          resolve(data);
        }
      });
    });

    req.on('error', (error) => {
      console.error('📹 HTTP error:', error);
      reject(error);
    });

    if (body) {
      req.write(typeof body === 'string' ? body : JSON.stringify(body));
    }

    req.end();
  });
});

// Handler to set Blink authentication
ipcMain.handle('set-blink-auth', async (event, { token, accountId, region }) => {
  console.log(`📹 set-blink-auth handler called`);
  setBlinkAuth({
    token,
    accountId,
    region,
    headerMode: 'bearer' // Start with bearer mode
  });
  return { success: true };
});

// Register the new Blink image fetcher with auth retry logic
registerBlinkImageFetcher();

console.log('📹 Blink IPC handlers registered successfully');

const createWindow = (): void => {
  // Get all displays for positioning
  const displays = screen.getAllDisplays();
  const primaryDisplay = screen.getPrimaryDisplay();

  console.log('🖥️  Available displays:');
  displays.forEach((display, index) => {
    console.log(`  Display ${index + 1}: ${display.bounds.width}x${display.bounds.height} at (${display.bounds.x}, ${display.bounds.y}) ${display === primaryDisplay ? '(PRIMARY)' : ''}`);
  });

  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 800,
    width: 1200,
    minHeight: 600,
    minWidth: 800,
    title: 'Sleep',
    icon: process.platform === 'darwin' ? undefined : 'assets/icon.png',
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
    titleBarStyle: process.platform === 'darwin' ? 'hiddenInset' : 'default',
    show: false, // Don't show until ready
    // Start on primary display but make it easy to move
    x: primaryDisplay.bounds.x + 100,
    y: primaryDisplay.bounds.y + 100,
  });

  // Create menu with display positioning options
  const createMenu = () => {
    const displays = screen.getAllDisplays();
    const displayMenuItems = displays.map((display, index) => ({
      label: `Move to Display ${index + 1} (${display.bounds.width}x${display.bounds.height})${display === screen.getPrimaryDisplay() ? ' - Primary' : ''}`,
      click: () => {
        // Move window to the selected display
        const bounds = display.bounds;
        mainWindow.setBounds({
          x: bounds.x + 50,
          y: bounds.y + 50,
          width: Math.min(1200, bounds.width - 100),
          height: Math.min(800, bounds.height - 100)
        });
        console.log(`🖥️  Moved window to Display ${index + 1}`);
      }
    }));

    const template = [
      {
        label: 'Window',
        submenu: [
          ...displayMenuItems,
          { type: 'separator' },
          {
            label: 'Toggle Fullscreen',
            accelerator: process.platform === 'darwin' ? 'Cmd+F' : 'F11',
            click: () => {
              mainWindow.setFullScreen(!mainWindow.isFullScreen());
            }
          },
          {
            label: 'Always on Top',
            type: 'checkbox',
            click: (menuItem: any) => {
              mainWindow.setAlwaysOnTop(menuItem.checked);
            }
          }
        ]
      },
      {
        label: 'View',
        submenu: [
          {
            label: 'Reload',
            accelerator: 'CmdOrCtrl+R',
            click: () => {
              mainWindow.reload();
            }
          },
          {
            label: 'Toggle Developer Tools',
            accelerator: process.platform === 'darwin' ? 'Alt+Cmd+I' : 'Ctrl+Shift+I',
            click: () => {
              mainWindow.webContents.toggleDevTools();
            }
          }
        ]
      }
    ];

    const menu = Menu.buildFromTemplate(template as any);
    Menu.setApplicationMenu(menu);
  };

  // Show window when ready to prevent visual flash
  mainWindow.once('ready-to-show', () => {
    mainWindow.show();
    createMenu(); // Create menu after window is ready
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools only in development
  if (process.env.NODE_ENV === 'development') {
    mainWindow.webContents.openDevTools();
  }

  // Handle window closed
  mainWindow.on('closed', () => {
    // Dereference the window object
  });

  // Initialize auto-updater
  const updater = new AutoUpdater(mainWindow);
  updater.startPeriodicCheck(24); // Check for updates every 24 hours

  // Add IPC handler for manual update check
  ipcMain.handle('check-for-updates', async () => {
    updater.checkForUpdates();
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
